//! proof composition is required to stitch different [`crate::program::RomCircuit`] together to
//! form an NIVC [`crate::program::data::ProgramData`].
//!
//! [`Manifest`] generated by client contains [`Request`] and [`Response`] which is used to create
//! HTTP and JSON circuits. To create the circuits, ROM is prepared containing circuits and private
//! input to each circuit.
//!
//! Circuits:
//! - Plaintext Authentication: verifies encryption of plaintext with TLS key matches ciphertext
//! - HTTP Verification: verifies HTTP headers and body
//! - JSON Extraction: verifies JSON keys in the response body
//!
//! # Example ROM for Request
//! ```json
//! {
//!    "PLAINTEXT_AUTHENTICATION": 0,
//!    "HTTP_VERIFICATION": 1
//! }
//! ```
//!
//! # Example ROM for Response
//! ```json
//! {
//!    "PLAINTEXT_AUTHENTICATION": 0,
//!    "HTTP_VERIFICATION": 1,
//!    "JSON_EXTRACTION": 2
//! }

use std::collections::HashMap;

use halo2curves::bn256::Fr;
use num_bigint::BigInt;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use tls_client2::CipherSuiteKey;

use crate::{
  program::{
    data::{CircuitData, FoldInput},
    F, G1,
  },
  witness::{
    compress_tree_hash, compute_http_header_witness, compute_http_witness, data_hasher,
    json_tree_hasher, json_value_digest, polynomial_digest, poseidon, request_initial_digest,
    response_initial_digest, ByteOrPad,
  },
  ProofError,
};

/// HTTP
const DATA_SIGNAL_NAME: &str = "data";

/// ideal circuit size to used for a plaintext
const CIRCUIT_SIZE: usize = 1024;
const MAX_HTTP_HEADERS: usize = 25;
const MAX_STACK_HEIGHT: usize = 10;

/// JSON key required to extract particular value from response
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JsonKey {
  /// Object key
  String(String),
  /// Array index
  Num(usize),
}

/// JSON keys: `["a", "b", 0, "c"]`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseBody {
  pub json: Vec<JsonKey>,
}

/// HTTP Response items required for circuits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
  /// HTTP response status
  pub status:  String,
  /// HTTP version
  #[serde(default = "default_version")]
  pub version: String,
  /// HTTP response message
  #[serde(default = "default_message")]
  pub message: String,
  /// HTTP headers to lock
  pub headers: HashMap<String, String>,
  /// HTTP body keys
  pub body:    ResponseBody,
}

/// HTTP Request items required for circuits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
  /// HTTP method (GET or POST)
  pub method:  String,
  /// HTTP request URL
  pub url:     String,
  /// HTTP version
  #[serde(default = "default_version")]
  pub version: String,
  /// Request headers to lock
  pub headers: HashMap<String, String>,
}

/// Default HTTP version
fn default_version() -> String { "HTTP/1.1".to_string() }
/// Default HTTP message
fn default_message() -> String { "OK".to_string() }

/// Manifest containing [`Request`] and [`Response`]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
  /// HTTP request lock items
  pub request:  Request,
  /// HTTP response lock items
  pub response: Response,
}

// TODO(Sambhav): can we remove usage of vec here?
/// encryption input for AES/CHACHA required to generate witness for the circuits
#[derive(Clone)]
pub struct EncryptionInput {
  /// 128-bit key
  pub key:        CipherSuiteKey,
  /// 96-bit IV
  pub iv:         [u8; 12],
  /// 128-bit AAD
  pub aad:        Vec<u8>,
  /// plaintext to be encrypted
  pub plaintext:  Vec<Vec<u8>>,
  /// ciphertext associated with plaintext
  pub ciphertext: Vec<Vec<u8>>,
  /// nonce sequence number
  pub seq:        u64,
}

/// TLS encryption input for request and response proving
pub struct TLSEncryption {
  pub request:  EncryptionInput,
  pub response: EncryptionInput,
}

/// encryption circuit input for AES/CHACHA
struct EncryptionCircuitInput {
  /// padded plaintext
  plaintext:  Vec<Vec<ByteOrPad>>,
  /// padded ciphertext
  ciphertext: Vec<Vec<ByteOrPad>>,
}

/// convert bytes to u32
fn to_u32_array(input: &[u8]) -> Vec<u32> {
  // Calculate padding needed to make length divisible by 4
  let padding_needed = (4 - (input.len() % 4)) % 4;

  // Create a new vector with padding
  let padded_input =
    input.iter().chain(std::iter::repeat(&0).take(padding_needed)).copied().collect::<Vec<u8>>();

  padded_input
    .chunks(4)
    .map(|chunk| {
      // Convert 4 bytes to u32 (little-endian)
      u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]])
    })
    .collect()
}

/// converts array of u32 to array of bits in little endian order
fn u32_array_to_le_bits(input: &[u32]) -> Vec<Vec<u8>> {
  input
    .iter()
    .map(|&num| {
      // Convert each u32 to a vector of bits (0 or 1)
      (0..32).map(|i| ((num >> (31 - i)) & 1) as u8).collect()
    })
    .collect()
}

/// convert bytes to 32 bit array and then little endian bits
pub fn to_chacha_input(input: &[u8]) -> Vec<Vec<u8>> { u32_array_to_le_bits(&to_u32_array(input)) }

/// create nonce for CHACHA20POLY1305
pub fn make_nonce(iv: [u8; 12], seq: u64) -> [u8; 12] {
  let mut nonce = [0u8; 12];
  nonce[4..].copy_from_slice(&seq.to_be_bytes());

  nonce.iter_mut().zip(iv.iter()).for_each(|(nonce, iv)| {
    *nonce ^= *iv;
  });

  nonce
}

/// pad plaintext and ciphertext to circuit size
fn pad_plaintext_authentication_inputs(inputs: &EncryptionInput) -> EncryptionCircuitInput {
  match inputs.key {
    CipherSuiteKey::CHACHA20POLY1305(_) => {
      let mut plaintext_packets = vec![];
      let mut ciphertext_packets = vec![];
      for (plaintext, ciphertext) in inputs.plaintext.iter().zip(inputs.ciphertext.iter()) {
        assert_eq!(plaintext.len(), ciphertext.len());
        plaintext_packets
          .push(ByteOrPad::from_bytes_with_padding(plaintext, CIRCUIT_SIZE - plaintext.len()));
        ciphertext_packets
          .push(ByteOrPad::from_bytes_with_padding(ciphertext, CIRCUIT_SIZE - plaintext.len()));
      }

      EncryptionCircuitInput { plaintext: plaintext_packets, ciphertext: ciphertext_packets }
    },
    CipherSuiteKey::AES128GCM(_) => {
      unimplemented!("Only CHACHA20POLY1305 is supported for now");
    },
  }
}

/// create ROM circuit data for encryption circuit from TLS inputs
///
/// # Arguments
/// - `inputs`: [`EncryptionInput`] containing TLS key, iv, aad for encryption circuit
/// - `padded_plaintext`: padded plaintext depending on the TLS [`CipherSuiteKey`]
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// **Note**: MAC is ignored from the ciphertext because circuit doesn't verify auth tag.
fn build_plaintext_authentication_circuit_inputs(
  inputs: &EncryptionInput,
  padded_plaintext: &[ByteOrPad],
  ciphertext_digest: F<G1>,
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
  plaintext_circuit_counter: usize,
) -> F<G1> {
  // handle different cipher suite, currently AES-GCM-128 & ChaCha20-Poly1305
  match inputs.key {
    CipherSuiteKey::CHACHA20POLY1305(key) => {
      let nonce = make_nonce(inputs.iv, inputs.seq + plaintext_circuit_counter as u64);

      let plaintext_index_counter = if plaintext_circuit_counter == 0 {
        0
      } else {
        inputs.plaintext[..plaintext_circuit_counter].iter().map(Vec::len).sum::<usize>()
      };

      // CHACHA rom opcode with private inputs
      private_inputs.push(HashMap::from([
        (String::from("key"), json!(to_chacha_input(&key))),
        (String::from("nonce"), json!(to_chacha_input(&nonce))),
        (String::from("counter"), json!(to_chacha_input(&[1]))),
        (String::from("plaintext"), json!(&padded_plaintext)),
        (String::from("plaintext_index_counter"), json!(plaintext_index_counter)),
        (
          String::from("ciphertext_digest"),
          json!(BigInt::from_bytes_le(num_bigint::Sign::Plus, &ciphertext_digest.to_bytes())
            .to_str_radix(10)),
        ),
      ]));

      let plaintext_digest = polynomial_digest(
        &ByteOrPad::as_bytes(padded_plaintext),
        ciphertext_digest,
        plaintext_index_counter as u64,
      );

      let packet_ciphertext_digest = data_hasher(&ByteOrPad::from_bytes_with_padding(
        &inputs.ciphertext[plaintext_circuit_counter],
        CIRCUIT_SIZE,
      ));
      plaintext_digest - packet_ciphertext_digest
    },
    CipherSuiteKey::AES128GCM(_) => {
      unimplemented!("Only CHACHA20POLY1305 is supported for now");
    },
  }
}

/// Build HTTP verification circuit inputs
///
/// # Arguments
/// - `inputs`: input bytes
/// - `ciphertext_digest`: ciphertext digest
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// # Returns
/// - `http_body`: body of the HTTP
fn build_http_verification_circuit_inputs(
  inputs: &[ByteOrPad],
  ciphertext_digest: F<G1>,
  headers: &HashMap<String, String>,
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
) -> (F<G1>, Vec<ByteOrPad>) {
  let plaintext_digest = polynomial_digest(&ByteOrPad::as_bytes(inputs), ciphertext_digest, 0);

  // compute hashes http start line and headers signals
  let mut main_digests = vec!["0".to_string(); MAX_HTTP_HEADERS + 1];
  let http_start_line_digest = polynomial_digest(
    &ByteOrPad::as_bytes(&compute_http_witness(inputs, super::witness::HttpMaskType::StartLine)),
    ciphertext_digest,
    0,
  );

  let http_start_line_digest_hashed = poseidon::<1>(&[http_start_line_digest]);

  let mut header_digests_hashed = vec![];
  main_digests[0] =
    BigInt::from_bytes_le(num_bigint::Sign::Plus, &http_start_line_digest.to_bytes())
      .to_str_radix(10);

  for header_name in headers.keys() {
    let (index, masked_header) = compute_http_header_witness(inputs, header_name.as_bytes());
    let header_digest =
      polynomial_digest(&ByteOrPad::as_bytes(&masked_header), ciphertext_digest, 0);
    header_digests_hashed.push(poseidon::<1>(&[header_digest]));

    main_digests[index + 1] =
      BigInt::from_bytes_le(num_bigint::Sign::Plus, &header_digest.to_bytes()).to_str_radix(10);
  }

  // initialise rom data and rom
  assert_eq!(inputs.len(), CIRCUIT_SIZE);
  private_inputs.push(HashMap::from([
    (String::from(DATA_SIGNAL_NAME), json!(&inputs)),
    (
      String::from("ciphertext_digest"),
      json!([BigInt::from_bytes_le(num_bigint::Sign::Plus, &ciphertext_digest.to_bytes())
        .to_str_radix(10)]),
    ),
    (String::from("main_digests"), json!(main_digests)),
  ]));

  let mut padded_http_body = compute_http_witness(inputs, crate::witness::HttpMaskType::Body);
  padded_http_body.resize(CIRCUIT_SIZE, ByteOrPad::Pad);

  let http_body_digest =
    polynomial_digest(&ByteOrPad::as_bytes(&padded_http_body), ciphertext_digest, 0);
  let http_body_digest_hashed = poseidon::<1>(&[http_body_digest]);

  let http_step_out = http_body_digest_hashed
    - http_start_line_digest_hashed
    - header_digests_hashed.iter().sum::<F<G1>>()
    - plaintext_digest;

  (http_step_out, padded_http_body)
}

/// Build JSON extraction circuit inputs
///
/// # Arguments
/// - `inputs`: valid input json bytes
/// - `keys`: JSON keys to mask
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// # Returns
/// - `masked_body`: masked body of the JSON
///
/// # Notes
/// Pads `inputs` to `CIRCUIT_SIZE` and computes the digest of the JSON key sequence.
fn build_json_extraction_circuit_inputs(
  inputs: &[ByteOrPad],
  ciphertext_digest: F<G1>,
  keys: &[JsonKey],
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
) -> Result<F<G1>, ProofError> {
  let sequence_digest = compress_tree_hash(
    ciphertext_digest,
    json_tree_hasher(ciphertext_digest, keys, MAX_STACK_HEIGHT),
  );
  let sequence_digest_hashed = poseidon::<1>(&[sequence_digest]);
  let data_digest_hashed =
    poseidon::<1>(&[polynomial_digest(&ByteOrPad::as_bytes(inputs), ciphertext_digest, 0)]);

  let value = json_value_digest(inputs, keys)?;
  let value_digest = polynomial_digest(&value, ciphertext_digest, 0);

  // extend inputs to correct circuit size and pad
  let mut padded_inputs = inputs.to_vec();
  padded_inputs.resize(CIRCUIT_SIZE, ByteOrPad::Pad);

  // compute json value from keys
  private_inputs.push(HashMap::from([
    (String::from(DATA_SIGNAL_NAME), json!(&padded_inputs)),
    (
      String::from("ciphertext_digest"),
      json!([BigInt::from_bytes_le(num_bigint::Sign::Plus, &ciphertext_digest.to_bytes())
        .to_str_radix(10)]),
    ),
    (
      String::from("sequence_digest"),
      json!([
        BigInt::from_bytes_le(num_bigint::Sign::Plus, &sequence_digest.to_bytes()).to_str_radix(10)
      ]),
    ),
    (
      String::from("value_digest"),
      json!(
        BigInt::from_bytes_le(num_bigint::Sign::Plus, &value_digest.to_bytes()).to_str_radix(10)
      ),
    ),
  ]));

  Ok(sequence_digest_hashed + data_digest_hashed)
}

/// NIVC ROM containing circuit data and rom
pub struct NIVCRom {
  /// [`CircuitData`] for each instruction
  pub circuit_data: HashMap<String, CircuitData>,
  /// NIVC ROM containing opcodes defining the computation.
  pub rom:          Vec<String>,
}

/// NIVC circuit inputs containing private inputs, fold inputs and initial nivc input
pub struct NivcCircuitInputs {
  /// private inputs to be used for each circuit defined circuit input label wise
  pub private_inputs:     Vec<HashMap<String, serde_json::Value>>,
  /// fold inputs to be used for each circuit, later expanded across folds
  pub fold_inputs:        HashMap<String, FoldInput>,
  /// initial public input
  pub initial_nivc_input: Vec<F<G1>>,
}

impl Request {
  /// Builds private inputs for [`Manifest`] request.
  ///
  /// # Circuits
  /// - plaintext authentication
  /// - http verification
  pub fn build_inputs(&self, inputs: &EncryptionInput) -> NivcCircuitInputs {
    assert_eq!(inputs.plaintext.len(), inputs.ciphertext.len());

    let mut private_inputs = vec![];
    let mut fold_inputs: HashMap<String, FoldInput> = HashMap::new();
    let mut public_inputs = vec![];

    let combined_plaintext: Vec<u8> = inputs.plaintext.iter().flatten().copied().collect();
    let combined_plaintext = ByteOrPad::from_bytes_with_padding(
      &combined_plaintext,
      CIRCUIT_SIZE - combined_plaintext.len(),
    );
    let EncryptionCircuitInput { plaintext, ciphertext } =
      pad_plaintext_authentication_inputs(inputs);

    let (ciphertext_digest, init_nivc_input) = request_initial_digest(self, &ciphertext);
    public_inputs.push(init_nivc_input);

    let mut plaintext_step_outs = Fr::zero();
    for (i, pt) in plaintext.iter().enumerate() {
      let plaintext_step_out = build_plaintext_authentication_circuit_inputs(
        inputs,
        pt,
        ciphertext_digest,
        &mut private_inputs,
        &mut fold_inputs,
        i,
      );
      plaintext_step_outs += plaintext_step_out;
      let plaintext_step_out = init_nivc_input + plaintext_step_outs;
      // debug!("plaintext_step_out: {:?}", field_element_to_base10_string(plaintext_step_out));
      public_inputs.push(plaintext_step_out);
    }

    assert_eq!(
      plaintext_step_outs,
      -ciphertext_digest
        + polynomial_digest(&ByteOrPad::as_bytes(&combined_plaintext), ciphertext_digest, 0)
    );

    let (http_step_out, _http_body) = build_http_verification_circuit_inputs(
      &combined_plaintext,
      ciphertext_digest,
      &self.headers,
      &mut private_inputs,
      &mut fold_inputs,
    );
    let http_step_out = public_inputs.last().unwrap() + http_step_out;
    public_inputs.push(http_step_out);

    NivcCircuitInputs { private_inputs, fold_inputs, initial_nivc_input: public_inputs }
  }

  /// builds ROM for [`Manifest`] request.
  /// # circuits
  /// - plaintext authentication
  /// - http verification
  pub fn build_rom(&self) -> NIVCRom {
    let plaintext_authentication_label = String::from("PLAINTEXT_AUTHENTICATION");
    let rom_data = HashMap::from([
      (plaintext_authentication_label.clone(), CircuitData { opcode: 0 }),
      (String::from("HTTP_VERIFICATION"), CircuitData { opcode: 1 }),
    ]);

    let rom = vec![plaintext_authentication_label, String::from("HTTP_VERIFICATION")];

    NIVCRom { circuit_data: rom_data, rom }
  }
}

impl Response {
  /// Builds private inputs for [`Manifest`] response.
  ///
  /// # Circuits
  /// - plaintext authentication
  /// - http verification
  /// - json extraction
  pub fn build_inputs(&self, inputs: &EncryptionInput) -> Result<NivcCircuitInputs, ProofError> {
    assert_eq!(inputs.plaintext.len(), inputs.ciphertext.len());

    let mut private_inputs = vec![];
    let mut fold_inputs: HashMap<String, FoldInput> = HashMap::new();
    let mut public_inputs = vec![];

    let combined_plaintext = inputs.plaintext.iter().flatten().copied().collect::<Vec<u8>>();
    let combined_plaintext = ByteOrPad::from_bytes_with_padding(
      &combined_plaintext,
      CIRCUIT_SIZE - combined_plaintext.len(),
    );

    let EncryptionCircuitInput { plaintext, ciphertext } =
      pad_plaintext_authentication_inputs(inputs);

    let (ciphertext_digest, init_nivc_input) =
      response_initial_digest(self, &ciphertext, MAX_STACK_HEIGHT);
    // debug!("ciphertext_digest: {:?}", field_element_to_base10_string(ciphertext_digest));
    // debug!("init_nivc_input: {:?}", field_element_to_base10_string(init_nivc_input));

    public_inputs.push(init_nivc_input);
    let mut plaintext_step_outs = Fr::zero();

    for (i, pt) in plaintext.iter().enumerate() {
      let plaintext_step_out = build_plaintext_authentication_circuit_inputs(
        inputs,
        pt,
        ciphertext_digest,
        &mut private_inputs,
        &mut fold_inputs,
        i,
      );
      plaintext_step_outs += plaintext_step_out;
      let plaintext_step_out = init_nivc_input + plaintext_step_outs;
      // debug!("plaintext_step_out: {:?}", field_element_to_base10_string(plaintext_step_out));
      public_inputs.push(plaintext_step_out);
    }

    assert_eq!(
      plaintext_step_outs,
      -ciphertext_digest
        + polynomial_digest(&ByteOrPad::as_bytes(&combined_plaintext), ciphertext_digest, 0)
    );

    let (http_step_out, http_body) = build_http_verification_circuit_inputs(
      &combined_plaintext,
      ciphertext_digest,
      &self.headers,
      &mut private_inputs,
      &mut fold_inputs,
    );
    // unwrap is secure, as we are sure that there is at least one element in the vector
    let http_step_out = public_inputs.last().unwrap() + http_step_out;
    // debug!("http_step_out: {:?}", field_element_to_base10_string(http_step_out));
    public_inputs.push(http_step_out);

    // json keys
    let json_step_out_check = build_json_extraction_circuit_inputs(
      &http_body,
      ciphertext_digest,
      &self.body.json,
      &mut private_inputs,
      &mut fold_inputs,
    )?;
    // debug!("json_step_out_check: {:?}", field_element_to_base10_string(json_step_out_check));
    assert_eq!(http_step_out - json_step_out_check, F::<G1>::zero());

    Ok(NivcCircuitInputs { fold_inputs, private_inputs, initial_nivc_input: public_inputs })
  }

  /// Builds ROM for [`Manifest`] response.
  ///
  /// # Circuits
  /// - plaintext authentication
  /// - http verification
  /// - json extraction
  ///
  /// # Returns
  /// - [`NIVCRom`] containing circuit data and rom
  pub fn build_rom(&self, response_packets: usize) -> NIVCRom {
    let plaintext_authentication_label = String::from("PLAINTEXT_AUTHENTICATION");
    // plaintext_authentication_label is duplicated `response_packets` times
    let mut rom_data = HashMap::new();
    (0..response_packets).for_each(|i| {
      rom_data
        .insert(format!("{}_{}", plaintext_authentication_label, i), CircuitData { opcode: 0 });
    });
    rom_data.insert(String::from("HTTP_VERIFICATION"), CircuitData { opcode: 1 });
    rom_data.insert(String::from("JSON_EXTRACTION"), CircuitData { opcode: 2 });

    let mut rom = vec![];
    (0..response_packets).for_each(|i| {
      rom.push(format!("{}_{}", plaintext_authentication_label, i));
    });
    rom.push(String::from("HTTP_VERIFICATION"));
    rom.push(String::from("JSON_EXTRACTION"));

    NIVCRom { circuit_data: rom_data, rom }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::tests::{
    mock_manifest, CHACHA20_CIPHERTEXT, CHACHA20_KEY, CHACHA20_NONCE, HTTP_RESPONSE_PLAINTEXT,
  };

  const TEST_MANIFEST_REQUEST: &[u8] = &[
    71, 69, 84, 32, 104, 116, 116, 112, 115, 58, 47, 47, 103, 105, 115, 116, 46, 103, 105, 116,
    104, 117, 98, 117, 115, 101, 114, 99, 111, 110, 116, 101, 110, 116, 46, 99, 111, 109, 47, 109,
    97, 116, 116, 101, 115, 47, 50, 51, 101, 54, 52, 102, 97, 97, 100, 98, 53, 102, 100, 52, 98,
    53, 49, 49, 50, 102, 51, 55, 57, 57, 48, 51, 100, 50, 53, 55, 50, 101, 47, 114, 97, 119, 47,
    55, 52, 101, 53, 49, 55, 97, 54, 48, 99, 50, 49, 97, 53, 99, 49, 49, 100, 57, 52, 102, 101, 99,
    56, 98, 53, 55, 50, 102, 54, 56, 97, 100, 100, 102, 97, 100, 101, 51, 57, 47, 101, 120, 97,
    109, 112, 108, 101, 46, 106, 115, 111, 110, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10, 104,
    111, 115, 116, 58, 32, 103, 105, 115, 116, 46, 103, 105, 116, 104, 117, 98, 117, 115, 101, 114,
    99, 111, 110, 116, 101, 110, 116, 46, 99, 111, 109, 13, 10, 97, 99, 99, 101, 112, 116, 45, 101,
    110, 99, 111, 100, 105, 110, 103, 58, 32, 105, 100, 101, 110, 116, 105, 116, 121, 13, 10, 99,
    111, 110, 110, 101, 99, 116, 105, 111, 110, 58, 32, 99, 108, 111, 115, 101, 13, 10, 97, 99, 99,
    101, 112, 116, 58, 32, 42, 47, 42, 0, 0,
  ];

  const TEST_MANIFEST: &str = r#"
  {
      "manifestVersion": "1",
      "id": "reddit-user-karma",
      "title": "Total Reddit Karma",
      "description": "Generate a proof that you have a certain amount of karma",
      "prepareUrl": "https://www.reddit.com/login/",
      "request": {
          "method": "GET",
          "url": "https://gist.githubusercontent.com/mattes/23e64faadb5fd4b5112f379903d2572e/raw/74e517a60c21a5c11d94fec8b572f68addfade39/example.json",
          "headers": {
              "host": "gist.githubusercontent.com",
              "connection": "close"
          },
          "body": {
              "userId": "<% userId %>"
          },
          "vars": {
              "userId": {
                  "regex": "[a-z]{,20}+"
              },
              "token": {
                  "type": "base64",
                  "length": 32
              }
          }
      },
      "response": {
          "status": "200",
          "headers": {
              "Content-Type": "application/json"
          },
          "body": {
              "json": [
                  "data",
                  "items",
                  0,
                  "profile",
                  "name"
              ],
              "contains": "this_string_exists_in_body"
          }
      }
  }
  "#;

  #[test]
  fn test_serialize() {
    let manifest: Manifest = serde_json::from_str(TEST_MANIFEST).unwrap();
    // verify defaults are working
    assert_eq!(manifest.request.version, "HTTP/1.1");
    assert_eq!(manifest.request.method, "GET");
    assert_eq!(manifest.request.headers.len(), 2);
    assert_eq!(manifest.request.headers.get("host").unwrap(), "gist.githubusercontent.com");

    // verify defaults are working
    assert_eq!(manifest.response.status, "200");
    assert_eq!(manifest.response.version, "HTTP/1.1");
    assert_eq!(manifest.response.headers.len(), 1);
    assert_eq!(manifest.response.headers.get("Content-Type").unwrap(), "application/json");
    assert_eq!(manifest.response.body.json.len(), 5);
  }

  #[test]
  fn generate_rom_from_request() {
    let manifest: Manifest = serde_json::from_str(TEST_MANIFEST).unwrap();

    let NivcCircuitInputs { fold_inputs, private_inputs, .. } =
      manifest.request.build_inputs(&EncryptionInput {
        key:        tls_client2::CipherSuiteKey::CHACHA20POLY1305(CHACHA20_KEY.1),
        iv:         CHACHA20_NONCE.1,
        aad:        [0; 12].to_vec(),
        plaintext:  vec![TEST_MANIFEST_REQUEST.to_vec()],
        ciphertext: vec![TEST_MANIFEST_REQUEST.to_vec()],
        seq:        0,
      });
    let NIVCRom { circuit_data: rom_data, rom } = manifest.request.build_rom();

    // CHACHA + HTTP verification
    assert_eq!(rom_data.len(), 2);
    assert_eq!(rom_data.get(&String::from("HTTP_VERIFICATION")).unwrap().opcode, 1);

    // should contain PLAINTEXT_AUTHENTICATION and HTTP_VERIFICATION
    assert_eq!(rom.len(), 1 + 1);

    // assert plaintext authentication inputs
    let plaintext_authentication_len = 0;
    assert_eq!(rom[plaintext_authentication_len], "PLAINTEXT_AUTHENTICATION");
    assert!(private_inputs[plaintext_authentication_len].contains_key("counter"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("nonce"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("key"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("plaintext"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("plaintext_index_counter"));

    // assert http verification inputs
    let http_instruction_len = 1;
    assert_eq!(rom[http_instruction_len], "HTTP_VERIFICATION");
    assert!(private_inputs[http_instruction_len].contains_key("main_digests"));
    assert!(private_inputs[http_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[http_instruction_len].contains_key("data"));

    assert!(fold_inputs.is_empty());
  }

  #[test]
  fn generate_rom_from_response() {
    let manifest: Manifest = mock_manifest();

    let NivcCircuitInputs { fold_inputs, private_inputs, .. } = manifest
      .response
      .build_inputs(&EncryptionInput {
        key:        tls_client2::CipherSuiteKey::CHACHA20POLY1305(CHACHA20_KEY.1),
        iv:         CHACHA20_NONCE.1,
        aad:        [0; 12].to_vec(),
        plaintext:  vec![HTTP_RESPONSE_PLAINTEXT.1.to_vec()],
        ciphertext: vec![CHACHA20_CIPHERTEXT.1.to_vec()],
        seq:        1,
      })
      .unwrap();
    let NIVCRom { circuit_data: rom_data, rom } = manifest.response.build_rom(1);

    // plaintext_authentication + http verification + json extraction
    assert_eq!(rom_data.len(), 3);
    assert_eq!(rom.len(), 3);

    // assert plaintext authentication inputs
    let plaintext_authentication_len = 0;
    assert_eq!(rom[plaintext_authentication_len], String::from("PLAINTEXT_AUTHENTICATION_0"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("counter"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("nonce"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("key"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("plaintext"));

    // assert http parse inputs
    let http_instruction_len = 1;
    assert_eq!(rom[http_instruction_len], String::from("HTTP_VERIFICATION"));
    assert!(private_inputs[http_instruction_len].contains_key("main_digests"));
    assert!(private_inputs[http_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[http_instruction_len].contains_key("data"));

    // check final circuit is extract
    let json_instruction_len = 2;
    assert_eq!(rom[json_instruction_len], String::from("JSON_EXTRACTION"));
    assert!(private_inputs[json_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("data"));
    assert!(private_inputs[json_instruction_len].contains_key("sequence_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("value_digest"));

    assert!(!fold_inputs.contains_key(&String::from("PLAINTEXT_AUTHENTICATION")));
  }

  #[test]
  fn chacha_inputs() {
    let counter_u32 = [1];
    let res = to_u32_array(&counter_u32);
    assert_eq!(res, [1]);

    let counter_back = u32_array_to_le_bits(&res);
    assert_eq!(counter_back, vec![vec![
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1
    ]]);

    let http_u32 = "HTTP".as_bytes();
    assert_eq!(to_u32_array(http_u32), [1347703880]);

    let http_bits = u32_array_to_le_bits(&to_u32_array(http_u32));
    assert_eq!(http_bits, [[
      0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
      0
    ]]);
  }
}
