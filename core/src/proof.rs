//! # Proof
//!
//! This module defines the data structures used to represent cryptographic proofs
//! of web interactions.
//!
//! A proof consists of:
//!
//! - Data about the manifest that was executed
//! - Cryptographic signatures verifying the execution
//!
//! ## Overview
//!
//! The proof system is designed to cryptographically verify that a specific HTTP interaction
//! occurred as defined in a manifest. This is accomplished through:
//!
//! 1. Generating a unique hash of the manifest
//! 2. Executing the HTTP request in a trusted execution environment (TEE)
//! 3. Creating a signed proof that includes the manifest hash and response data
//! 4. Providing cryptographic signatures that can be verified by third parties
//!
//! ## Key Components
//!
//! - [`TeeProof`]: The top-level proof structure that combines proof data with signatures
//! - [`TeeProofData`]: Contains the essential data being proven (manifest hash)
//! - [`SignedVerificationReply`]: Contains cryptographic signatures and verification data
//!
//! ## Verification Process
//!
//! To verify a proof:
//!
//! 1. Extract the manifest hash from `TeeProofData`
//! 2. Verify the signature in `SignedVerificationReply` using the provided signer address
//! 3. Confirm that the digest in the signature matches the expected value
//! 4. Optionally verify the Merkle proof if the implementation uses a Merkle tree

use std::convert::TryFrom;

use serde::{Deserialize, Serialize};

/// Represents a cryptographically signed verification response from a trusted execution
/// environment.
///
/// This structure contains all the cryptographic elements needed to verify that a specific
/// manifest was executed in a trusted environment.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SignedVerificationReply {
  /// A list of hashes representing the leaves of a Merkle tree.
  ///
  /// These leaves can be used to construct a Merkle proof, which efficiently verifies
  /// that a specific piece of data is included in a larger dataset without requiring
  /// the entire dataset.
  pub merkle_leaves: Vec<String>,

  /// The cryptographic digest (hash) of the data being verified, typically in hex format.
  ///
  /// This digest uniquely identifies the content being proven and is what gets signed
  /// by the trusted execution environment.
  pub digest: String,

  /// The complete ECDSA signature as a single string.
  ///
  /// This signature is generated by the trusted execution environment and proves that
  /// the environment attests to the validity of the digest.
  pub signature: String,

  /// The r component of the ECDSA signature.
  ///
  /// In ECDSA, a signature consists of two values (r,s). This field contains the r value,
  /// typically represented as a hexadecimal string.
  pub signature_r: String,

  /// The s component of the ECDSA signature.
  ///
  /// In ECDSA, a signature consists of two values (r,s). This field contains the s value,
  /// typically represented as a hexadecimal string.
  pub signature_s: String,

  /// The recovery ID for the ECDSA signature.
  ///
  /// This value (typically 0 or 1) is used to recover the public key from the signature.
  /// It's essential for Ethereum-style signature verification.
  pub signature_v: u8,

  /// The Ethereum address of the signer.
  ///
  /// This address represents the public key that signed the digest. Verifiers can use
  /// this address to confirm that the signature was created by a trusted entity.
  pub signer: String,
}

/// The top-level proof structure that combines the proof data with its cryptographic signature.
///
/// A `TeeProof` represents a complete, verifiable proof that a specific manifest was executed
/// in a trusted execution environment (TEE).
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TeeProof {
  /// The core data being proven, including the manifest hash.
  ///
  /// This field contains the essential information about what is being proven,
  /// specifically the cryptographic hash of the manifest that was executed.
  pub data: TeeProofData,

  /// Cryptographic signatures and verification data that authenticate the proof.
  ///
  /// This field contains all the cryptographic elements needed to verify that the
  /// proof was generated by a trusted execution environment.
  pub signature: SignedVerificationReply,
}

impl TryFrom<&[u8]> for TeeProof {
  type Error = serde_json::Error;

  /// Attempts to deserialize a byte slice into a `TeeProof`.
  ///
  /// This implementation allows for easy conversion from JSON bytes to a structured proof.
  ///
  /// # Errors
  ///
  /// Returns a `serde_json::Error` if deserialization fails.
  fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> { serde_json::from_slice(bytes) }
}

impl TryFrom<TeeProof> for Vec<u8> {
  type Error = serde_json::Error;

  /// Attempts to serialize a `TeeProof` into a byte vector.
  ///
  /// This implementation allows for easy conversion from a structured proof to JSON bytes.
  ///
  /// # Errors
  ///
  /// Returns a `serde_json::Error` if serialization fails.
  fn try_from(proof: TeeProof) -> Result<Self, Self::Error> { serde_json::to_vec(&proof) }
}

/// Contains the essential data being proven by a `TeeProof`.
///
/// This structure holds the cryptographic hash of the manifest that was executed,
/// which serves as a unique identifier for the specific HTTP interaction that was proven.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TeeProofData {
  /// A byte vector containing the cryptographic hash of the manifest.
  ///
  /// This hash uniquely identifies the manifest and can be used to verify that the
  /// correct manifest was executed. It's typically a Keccak-256 hash (32 bytes)
  /// that serves as a fingerprint of the entire manifest content.
  ///
  /// Verifiers can independently compute this hash from the original manifest and
  /// compare it with the value in the proof to ensure they're verifying the
  /// expected interaction.
  pub manifest_hash: Vec<u8>,
}
