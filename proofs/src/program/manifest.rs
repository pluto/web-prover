//! proof composition is required to stitch different [`crate::program::RomCircuit`] together to
//! form an NIVC [`crate::program::data::ProgramData`].
//!
//! [`Manifest`] generated by client contains [`Request`] and [`Response`] which is used to create
//! HTTP and JSON circuits. To create the circuits, ROM is prepared containing circuits and private
//! input to each circuit.
//!
//! Circuits:
//! - Plaintext Authentication: verifies encryption of plaintext with TLS key matches ciphertext
//! - HTTP Verification: verifies HTTP headers and body
//! - JSON Extraction: verifies JSON keys in the response body
//!
//! # Example ROM for Request
//! ```json
//! {
//!    "PLAINTEXT_AUTHENTICATION": 0,
//!    "HTTP_VERIFICATION": 1
//! }
//! ```
//!
//! # Example ROM for Response
//! ```json
//! {
//!    "PLAINTEXT_AUTHENTICATION": 0,
//!    "HTTP_VERIFICATION": 1,
//!    "JSON_EXTRACTION": 2
//! }

use std::collections::HashMap;

use ff::Field;
use num_bigint::BigInt;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use tls_client2::CipherSuiteKey;
use tracing::debug;
use web_proof_circuits_witness_generator::{
  data_hasher, field_element_to_base10_string,
  http::{
    compute_http_witness, headers_to_bytes, parser::parse as http_parse, HttpMaskType,
    RawHttpMachine,
  },
  json::{json_value_digest, parser::parse, JsonKey, RawJsonMachine},
  polynomial_digest, poseidon, ByteOrPad,
};

use crate::{
  program::{
    data::{CircuitData, FoldInput},
    F, G1,
  },
  ProofError,
};

/// HTTP
const DATA_SIGNAL_NAME: &str = "data";

/// ideal circuit size to used for a plaintext
const CIRCUIT_SIZE: usize = 1024;
const PUBLIC_IO_VARS: usize = 11;
const MAX_HTTP_HEADERS: usize = 25;
const MAX_STACK_HEIGHT: usize = 10;

/// Manifest containing [`Request`] and [`Response`]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
  /// HTTP request lock items
  pub request:  Request,
  /// HTTP response lock items
  pub response: Response,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseBody {
  pub json: Vec<JsonKey>,
}

/// Default HTTP version
pub fn default_version() -> String { "HTTP/1.1".to_string() }
/// Default HTTP message
pub fn default_message() -> String { "OK".to_string() }

/// HTTP Response items required for circuits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
  /// HTTP response status
  pub status:  String,
  /// HTTP version
  #[serde(default = "default_version")]
  pub version: String,
  /// HTTP response message
  #[serde(default = "default_message")]
  pub message: String,
  /// HTTP headers to lock
  pub headers: HashMap<String, String>,
  /// HTTP body keys
  pub body:    ResponseBody,
}

/// HTTP Request items required for circuits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
  /// HTTP method (GET or POST)
  pub method:  String,
  /// HTTP request URL
  pub url:     String,
  /// HTTP version
  #[serde(default = "default_version")]
  pub version: String,
  /// Request headers to lock
  pub headers: HashMap<String, String>,
}

// TODO(Sambhav): can we remove usage of vec here?
/// encryption input for AES/CHACHA required to generate witness for the circuits
#[derive(Clone)]
pub struct EncryptionInput {
  /// 128-bit key
  pub key:        CipherSuiteKey,
  /// 96-bit IV
  pub iv:         [u8; 12],
  /// 128-bit AAD
  pub aad:        Vec<u8>,
  /// plaintext to be encrypted
  pub plaintext:  Vec<Vec<u8>>,
  /// ciphertext associated with plaintext
  pub ciphertext: Vec<Vec<u8>>,
  /// nonce sequence number
  pub seq:        u64,
}

/// TLS encryption input for request and response proving
pub struct TLSEncryption {
  pub request:  EncryptionInput,
  pub response: EncryptionInput,
}

// TODO: can remove string usage here
/// NIVC ROM containing circuit data and rom
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NIVCRom {
  /// [`CircuitData`] for each instruction
  pub circuit_data: HashMap<String, CircuitData>,
  /// NIVC ROM containing opcodes defining the computation.
  pub rom:          Vec<String>,
}

/// NIVC circuit inputs containing private inputs, fold inputs and initial nivc input
pub struct NivcCircuitInputs {
  /// private inputs to be used for each circuit defined circuit input label wise
  pub private_inputs:     Vec<HashMap<String, serde_json::Value>>,
  /// fold inputs to be used for each circuit, later expanded across folds
  pub fold_inputs:        HashMap<String, FoldInput>,
  /// initial public input
  // TODO: change this to array
  pub initial_nivc_input: [F<G1>; PUBLIC_IO_VARS],
}

pub struct InitialNIVCInputs {
  pub ciphertext_digest:  F<G1>,
  pub initial_nivc_input: [F<G1>; PUBLIC_IO_VARS],
  pub headers_digest:     Vec<F<G1>>,
}

/// convert bytes to u32
fn to_u32_array(input: &[u8]) -> Vec<u32> {
  // Calculate padding needed to make length divisible by 4
  let padding_needed = (4 - (input.len() % 4)) % 4;

  // Create a new vector with padding
  let padded_input =
    input.iter().chain(std::iter::repeat(&0).take(padding_needed)).copied().collect::<Vec<u8>>();

  padded_input
    .chunks(4)
    .map(|chunk| {
      // Convert 4 bytes to u32 (little-endian)
      u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]])
    })
    .collect()
}

/// converts array of u32 to array of bits in little endian order
fn u32_array_to_le_bits(input: &[u32]) -> Vec<Vec<u8>> {
  input
    .iter()
    .map(|&num| {
      // Convert each u32 to a vector of bits (0 or 1)
      (0..32).map(|i| ((num >> (31 - i)) & 1) as u8).collect()
    })
    .collect()
}

/// convert bytes to 32 bit array and then little endian bits
pub fn to_chacha_input(input: &[u8]) -> Vec<Vec<u8>> { u32_array_to_le_bits(&to_u32_array(input)) }

/// create nonce for CHACHA20POLY1305
pub fn make_nonce(iv: [u8; 12], seq: u64) -> [u8; 12] {
  let mut nonce = [0u8; 12];
  nonce[4..].copy_from_slice(&seq.to_be_bytes());

  nonce.iter_mut().zip(iv.iter()).for_each(|(nonce, iv)| {
    *nonce ^= *iv;
  });

  nonce
}

/// create ROM circuit data for encryption circuit from TLS inputs
///
/// ## Arguments
/// - `inputs`: [`EncryptionInput`] containing TLS key, iv, aad for encryption circuit
/// - `polynomial input`: randomised input for circuit input digest
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// ## Note:
/// - MAC is ignored from the ciphertext because circuit doesn't verify auth tag.
/// - handle different cipher suite, currently AES-GCM-128 & ChaCha20-Poly1305
fn build_plaintext_authentication_circuit_inputs(
  inputs: &EncryptionInput,
  polynomial_input: F<G1>,
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
) -> Result<F<G1>, ProofError> {
  let mut plaintext_step_out = F::<G1>::ZERO;

  let key = inputs.key.as_ref();
  assert_eq!(key.len(), 32, "Only CHACHA20POLY1305 is supported for now");

  let mut curr_plaintext_index = 0;
  let mut prev_ciphertext_digest = F::<G1>::ZERO;
  for (plaintext_circuit_counter, (pt, ct)) in
    inputs.plaintext.iter().zip(inputs.ciphertext.iter()).enumerate()
  {
    assert!(pt.len() <= CIRCUIT_SIZE, "Plaintext is larger than circuit size");
    assert_eq!(pt.len(), ct.len(), "Plaintext and ciphertext length mismatch");

    let padded_plaintext = ByteOrPad::from_bytes_with_padding(&pt, CIRCUIT_SIZE - pt.len());
    let nonce = make_nonce(inputs.iv, inputs.seq + plaintext_circuit_counter as u64);

    // CHACHA rom opcode with private inputs
    private_inputs.push(HashMap::from([
      (String::from("key"), json!(to_chacha_input(&key))),
      (String::from("nonce"), json!(to_chacha_input(&nonce))),
      (String::from("counter"), json!(to_chacha_input(&[1]))),
      (String::from("plaintext"), json!(&padded_plaintext)),
      (
        String::from("ciphertext_digest"),
        json!(BigInt::from_bytes_le(num_bigint::Sign::Plus, &polynomial_input.to_bytes())
          .to_str_radix(10)),
      ),
    ]));

    let plaintext_digest = polynomial_digest(pt, polynomial_input, curr_plaintext_index as u64);

    prev_ciphertext_digest = data_hasher(
      &ByteOrPad::from_bytes_with_padding(
        &inputs.ciphertext[plaintext_circuit_counter],
        CIRCUIT_SIZE - ct.len(),
      ),
      prev_ciphertext_digest,
    );

    curr_plaintext_index += pt.len();
    plaintext_step_out += plaintext_digest;
  }

  Ok(plaintext_step_out - prev_ciphertext_digest)
}

/// Build HTTP verification circuit inputs
///
/// # Arguments
/// - `inputs`: input bytes
/// - `ciphertext_digest`: ciphertext digest
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// # Returns
/// - `http_body`: body of the HTTP
fn build_http_verification_circuit_inputs(
  plaintext_chunks: &[Vec<u8>],
  polynomial_input: F<G1>,
  headers_digest: &[F<G1>],
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
) -> Result<(F<G1>, Vec<u8>), ProofError> {
  // pad request plaintext and ciphertext to circuit size
  let plaintext = plaintext_chunks.iter().flatten().cloned().collect::<Vec<u8>>();

  let mut main_digests =
    headers_digest.iter().map(|h| field_element_to_base10_string(*h)).collect::<Vec<_>>();
  main_digests
    .extend(std::iter::repeat("0".to_string()).take(MAX_HTTP_HEADERS + 1 - headers_digest.len()));

  debug!("main_digests: {:?}", main_digests);

  let states = http_parse(&plaintext, polynomial_input)?;

  for (i, pt) in plaintext.chunks(CIRCUIT_SIZE).enumerate() {
    let state = if i == 0 {
      RawHttpMachine::initial_state()
    } else {
      RawHttpMachine::from(states[CIRCUIT_SIZE * i - 1])
    };
    private_inputs.push(HashMap::from([
      (
        String::from(DATA_SIGNAL_NAME),
        json!(ByteOrPad::from_bytes_with_padding(&pt, CIRCUIT_SIZE - pt.len())),
      ),
      (
        String::from("ciphertext_digest"),
        json!([BigInt::from_bytes_le(num_bigint::Sign::Plus, &polynomial_input.to_bytes())
          .to_str_radix(10)]),
      ),
      (String::from("main_digests"), json!(main_digests)),
      (String::from("machine_state"), json!(RawHttpMachine::from(state))),
    ]));
  }
  let plaintext_digest = polynomial_digest(&plaintext, polynomial_input, 0);

  // TODO (Sambhav): verify that headers digest calculated in initial input match or maybe we check
  // it in initial input

  let http_body = compute_http_witness(&plaintext, HttpMaskType::Body);
  debug!("HTTP body: {:?}", http_body.len());

  let http_body_digest = polynomial_digest(&http_body, polynomial_input, 0);

  Ok((http_body_digest - plaintext_digest, http_body))
}

/// Build JSON extraction circuit inputs
///
/// # Arguments
/// - `inputs`: valid input json bytes
/// - `keys`: JSON keys to mask
/// - `private_inputs`: private inputs to be used in the circuit
/// - `fold_inputs`: fold inputs to be used in the circuit
///
/// # Returns
/// - `masked_body`: masked body of the JSON
///
/// # Notes
/// Pads `inputs` to `CIRCUIT_SIZE` and computes the digest of the JSON key sequence.
fn build_json_extraction_circuit_inputs(
  inputs: &[u8],
  polynomial_input: F<G1>,
  keys: &[JsonKey],
  private_inputs: &mut Vec<HashMap<String, Value>>,
  _fold_inputs: &mut HashMap<String, FoldInput>,
) -> Result<F<G1>, ProofError> {
  let raw_response_json_machine =
    RawJsonMachine::<MAX_STACK_HEIGHT>::from_chosen_sequence_and_input(polynomial_input, &keys)?;
  let sequence_digest = raw_response_json_machine.compress_tree_hash();

  let value = json_value_digest::<MAX_STACK_HEIGHT>(&inputs, keys)?;
  let value_digest = polynomial_digest(&value, polynomial_input, 0);

  // no need to supply padded input as state is always from valid ascii
  let states = parse::<MAX_STACK_HEIGHT>(inputs, polynomial_input)?;

  for (i, pt) in inputs.chunks(CIRCUIT_SIZE).enumerate() {
    let state = if i == 0 {
      RawJsonMachine::initial_state()
    } else {
      RawJsonMachine::from(states[CIRCUIT_SIZE * i - 1].clone())
    };

    let state =
      state.flatten().iter().map(|f| field_element_to_base10_string(*f)).collect::<Vec<String>>();
    // debug!("state: {:?}", state);
    private_inputs.push(HashMap::from([
      (
        String::from(DATA_SIGNAL_NAME),
        json!(&ByteOrPad::from_bytes_with_padding(&pt, CIRCUIT_SIZE - pt.len())),
      ),
      (
        String::from("ciphertext_digest"),
        json!([BigInt::from_bytes_le(num_bigint::Sign::Plus, &polynomial_input.to_bytes())
          .to_str_radix(10)]),
      ),
      (
        String::from("sequence_digest"),
        json!([BigInt::from_bytes_le(num_bigint::Sign::Plus, &sequence_digest.to_bytes())
          .to_str_radix(10)]),
      ),
      (
        String::from("value_digest"),
        json!(
          BigInt::from_bytes_le(num_bigint::Sign::Plus, &value_digest.to_bytes()).to_str_radix(10)
        ),
      ),
      (String::from("state"), json!(state)),
    ]));
  }

  let data_digest = polynomial_digest(inputs, polynomial_input, 0);

  Ok(value_digest - data_digest)
}

impl Manifest {
  pub fn initial_inputs<const MAX_STACK_HEIGHT: usize>(
    &self,
    // TODO (Sambhav): can remove copying
    request_ciphertext: &[Vec<u8>],
    response_ciphertext: &[Vec<u8>],
  ) -> Result<InitialNIVCInputs, ProofError> {
    let padded_request_ciphertext = request_ciphertext
      .iter()
      .map(|c| ByteOrPad::from_bytes_with_padding(c, CIRCUIT_SIZE - c.len()))
      .collect::<Vec<Vec<ByteOrPad>>>();
    let padded_response_ciphertext = response_ciphertext
      .iter()
      .map(|c| ByteOrPad::from_bytes_with_padding(c, CIRCUIT_SIZE - c.len()))
      .collect::<Vec<Vec<ByteOrPad>>>();

    let mut ciphertext_digest = F::<G1>::ZERO;
    padded_request_ciphertext
      .iter()
      .for_each(|c| ciphertext_digest = data_hasher(c, ciphertext_digest));
    padded_response_ciphertext
      .iter()
      .for_each(|c| ciphertext_digest = data_hasher(c, ciphertext_digest));

    // TODO: This assumes the start line format here as well.
    // digest the start line for request/response using the ciphertext_digest as a random input
    let request_start_line_bytes =
      format!("{} {} {}", &self.request.method, &self.request.url, &self.request.version);
    let request_start_line_digest =
      polynomial_digest(request_start_line_bytes.as_bytes(), ciphertext_digest, 0);
    debug!(
      "WITNESS (request): start_line_digest={:?}, hex={:?}",
      request_start_line_digest,
      hex::encode(request_start_line_digest.to_bytes())
    );

    let response_start_line_bytes =
      format!("{} {} {}", &self.response.version, &self.response.status, &self.response.message);
    let response_start_line_digest =
      polynomial_digest(response_start_line_bytes.as_bytes(), ciphertext_digest, 0);

    // Digest all the headers
    let request_header_bytes = headers_to_bytes(&self.request.headers);
    let request_headers_digest =
      request_header_bytes.map(|bytes| polynomial_digest(&bytes, ciphertext_digest, 0));
    // debug!(
    //   "WITNESS (request): headers_digest={:?}, hex={:?}",
    //   request_headers_digest,
    //   request_headers_digest.clone().into_iter().map(|f| hex::encode(f.to_bytes()))
    // );

    let response_header_bytes = headers_to_bytes(&self.response.headers);
    let response_headers_digest =
      response_header_bytes.map(|bytes| polynomial_digest(&bytes, ciphertext_digest, 0));
    // debug!(
    //   "WITNESS (response): headers_digest={:?}, hex={:?}",
    //   response_headers_digest,
    //   response_headers_digest.clone().into_iter().map(|f| hex::encode(f.to_bytes()))
    // );

    // Digest the JSON sequence
    let raw_response_json_machine =
      RawJsonMachine::<MAX_STACK_HEIGHT>::from_chosen_sequence_and_input(
        ciphertext_digest,
        &self.response.body.json,
      )?;
    let json_sequence_digest_hash =
      poseidon::<1>(&[raw_response_json_machine.compress_tree_hash()]);

    // push request/response start line digest and headers digest into one all_digest vec
    let mut all_digest = vec![request_start_line_digest, response_start_line_digest];
    all_digest.extend(request_headers_digest);
    all_digest.extend(response_headers_digest);

    let header_verification_lock = all_digest.iter().map(|d| poseidon::<1>(&[*d])).sum::<F<G1>>();
    let num_matches = 1 + self.request.headers.len() + 1 + self.response.headers.len();

    Ok(InitialNIVCInputs {
      ciphertext_digest,
      initial_nivc_input: [
        ciphertext_digest,
        F::<G1>::ONE,
        F::<G1>::ONE,
        F::<G1>::ONE,
        header_verification_lock,
        F::<G1>::from(num_matches as u64),
        F::<G1>::ZERO,
        F::<G1>::ONE,
        F::<G1>::ZERO,
        json_sequence_digest_hash,
        F::<G1>::ZERO,
      ],
      headers_digest: all_digest,
    })
  }

  pub fn build_inputs(
    &self,
    request_inputs: &EncryptionInput,
    response_inputs: &EncryptionInput,
  ) -> Result<NivcCircuitInputs, ProofError> {
    assert_eq!(request_inputs.plaintext.len(), request_inputs.ciphertext.len());
    assert_eq!(response_inputs.plaintext.len(), response_inputs.ciphertext.len());

    let mut private_inputs = vec![];
    let mut fold_inputs: HashMap<String, FoldInput> = HashMap::new();

    let InitialNIVCInputs { ciphertext_digest, initial_nivc_input, headers_digest } =
      self.initial_inputs::<MAX_STACK_HEIGHT>(
        &request_inputs.ciphertext,
        &response_inputs.ciphertext,
      )?;

    let request_plaintext_step_out = build_plaintext_authentication_circuit_inputs(
      request_inputs,
      ciphertext_digest,
      &mut private_inputs,
      &mut fold_inputs,
    )?;
    // debug!("private_inputs: {:?}", private_inputs.len());

    let (request_http_verification_step_out, _) = build_http_verification_circuit_inputs(
      &request_inputs.plaintext,
      ciphertext_digest,
      &headers_digest,
      &mut private_inputs,
      &mut fold_inputs,
    )?;
    // debug!("private_inputs: {:?}", private_inputs.len());

    let response_plaintext_step_out = build_plaintext_authentication_circuit_inputs(
      response_inputs,
      ciphertext_digest,
      &mut private_inputs,
      &mut fold_inputs,
    )?;

    // debug!("private_inputs: {:?}", private_inputs.len());
    let (response_http_verification_step_out, response_body) =
      build_http_verification_circuit_inputs(
        &response_inputs.plaintext,
        ciphertext_digest,
        &headers_digest,
        &mut private_inputs,
        &mut fold_inputs,
      )?;

    let json_extraction_step_out = build_json_extraction_circuit_inputs(
      &response_body,
      ciphertext_digest,
      &self.response.body.json,
      &mut private_inputs,
      &mut fold_inputs,
    )?;

    Ok(NivcCircuitInputs { private_inputs, fold_inputs, initial_nivc_input })
  }

  /// Builds ROM for [`Manifest`] request and response.
  pub fn build_rom(
    &self,
    request_inputs: &EncryptionInput,
    response_inputs: &EncryptionInput,
  ) -> NIVCRom {
    let plaintext_authentication_label = String::from("PLAINTEXT_AUTHENTICATION");
    let http_verification_label = String::from("HTTP_VERIFICATION");
    let json_extraction_label = String::from("JSON_EXTRACTION");

    let mut rom = vec![];
    // ------------------- Request -------------------

    let combined_request_plaintext_length: usize =
      request_inputs.plaintext.iter().map(|x| x.len()).sum();

    // plaintext_authentication_label is duplicated `response_packets` times
    let mut rom_data = HashMap::new();
    (0..request_inputs.ciphertext.len()).for_each(|i| {
      let plaintext_circuit = format!("{}_{}", plaintext_authentication_label, i);
      rom_data.insert(plaintext_circuit.clone(), CircuitData { opcode: 0 });
      rom.push(plaintext_circuit);
    });
    // calculate number of circuits required for request, i.e. ceil(length/CIRCUIT_SIZE)
    let request_circuit_count =
      (combined_request_plaintext_length as f64 / CIRCUIT_SIZE as f64).ceil() as usize;
    (0..request_circuit_count).for_each(|i| {
      let http_circuit = format!("{}_{}", http_verification_label, i);
      rom_data.insert(http_circuit.clone(), CircuitData { opcode: 1 });
      rom.push(http_circuit);
    });

    // ------------------- Response -------------------

    let combined_response_plaintext_length: usize =
      response_inputs.plaintext.iter().map(|x| x.len()).sum();

    // plaintext_authentication_label is duplicated `response_packets` times
    (0..response_inputs.ciphertext.len()).for_each(|i| {
      let plaintext_circuit =
        format!("{}_{}", plaintext_authentication_label, i + request_inputs.ciphertext.len());
      rom_data.insert(plaintext_circuit.clone(), CircuitData { opcode: 0 });
      rom.push(plaintext_circuit);
    });

    // calculate number of circuits required for response, i.e. ceil(length/CIRCUIT_SIZE)
    let response_circuit_count =
      (combined_response_plaintext_length as f64 / CIRCUIT_SIZE as f64).ceil() as usize;
    (0..response_circuit_count).for_each(|i| {
      let http_circuit = format!("{}_{}", http_verification_label, i + request_circuit_count);
      rom_data.insert(http_circuit.clone(), CircuitData { opcode: 1 });
      rom.push(http_circuit);
    });

    let combined_response =
      response_inputs.plaintext.iter().flatten().cloned().collect::<Vec<u8>>();
    let response_body = compute_http_witness(&combined_response, HttpMaskType::Body);
    let response_json_circuit_count =
      (response_body.len() as f64 / CIRCUIT_SIZE as f64).ceil() as usize;

    (0..response_json_circuit_count).for_each(|i| {
      let json_circuit = format!("{}_{}", json_extraction_label, i);
      rom_data.insert(json_circuit.clone(), CircuitData { opcode: 2 });
      rom.push(json_circuit);
    });

    NIVCRom { circuit_data: rom_data, rom }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::tests::{
    inputs::{
      complex_manifest, complex_request_inputs, complex_response_inputs, simple_request_inputs,
      TEST_MANIFEST,
    },
    CHACHA20_CIPHERTEXT, CHACHA20_KEY, CHACHA20_NONCE, HTTP_RESPONSE_PLAINTEXT,
  };

  #[test]
  fn test_serialize() {
    let manifest: Manifest = serde_json::from_str(TEST_MANIFEST).unwrap();
    // verify defaults are working
    assert_eq!(manifest.request.version, "HTTP/1.1");
    assert_eq!(manifest.request.method, "GET");
    assert_eq!(manifest.request.headers.len(), 2);
    assert_eq!(manifest.request.headers.get("host").unwrap(), "gist.githubusercontent.com");

    // verify defaults are working
    assert_eq!(manifest.response.status, "200");
    assert_eq!(manifest.response.version, "HTTP/1.1");
    assert_eq!(manifest.response.headers.len(), 1);
    assert_eq!(manifest.response.headers.get("Content-Type").unwrap(), "application/json");
    assert_eq!(manifest.response.body.json.len(), 5);
  }

  fn simple_inputs() -> (EncryptionInput, EncryptionInput) {
    (simple_request_inputs(), EncryptionInput {
      key:        tls_client2::CipherSuiteKey::CHACHA20POLY1305(CHACHA20_KEY.1),
      iv:         CHACHA20_NONCE.1,
      aad:        [0; 12].to_vec(),
      plaintext:  vec![HTTP_RESPONSE_PLAINTEXT.1.to_vec()],
      ciphertext: vec![CHACHA20_CIPHERTEXT.1.to_vec()],
      seq:        1,
    })
  }

  fn complex_inputs() -> (EncryptionInput, EncryptionInput) {
    (complex_request_inputs(), complex_response_inputs())
  }

  #[test]
  fn generate_rom_from_simple_inputs() {
    let manifest: Manifest = serde_json::from_str(TEST_MANIFEST).unwrap();

    let (request_inputs, response_inputs) = simple_inputs();

    let NivcCircuitInputs { fold_inputs, private_inputs, .. } =
      manifest.build_inputs(&request_inputs, &response_inputs).unwrap();
    let NIVCRom { circuit_data: rom_data, rom } =
      manifest.build_rom(&request_inputs, &response_inputs);

    // request: plaintext_authentication + http verification
    // response: plaintext_authentication + http verification + json extraction
    assert_eq!(
      rom_data.len(),
      request_inputs.ciphertext.len() + 1 + response_inputs.ciphertext.len() + 1 + 1
    );
    assert_eq!(rom_data.get(&String::from("HTTP_VERIFICATION_0")).unwrap().opcode, 1);
    assert_eq!(rom_data.get(&String::from("PLAINTEXT_AUTHENTICATION_0")).unwrap().opcode, 0);
    assert_eq!(rom_data.get(&String::from("PLAINTEXT_AUTHENTICATION_1")).unwrap().opcode, 0);
    assert_eq!(rom_data.get(&String::from("HTTP_VERIFICATION_1")).unwrap().opcode, 1);
    assert_eq!(rom_data.get(&String::from("JSON_EXTRACTION_0")).unwrap().opcode, 2);

    // should be same length as rom_data
    assert_eq!(rom.len(), rom_data.len());

    // assert plaintext authentication inputs
    let plaintext_authentication_len = 0;
    assert_eq!(rom[plaintext_authentication_len], "PLAINTEXT_AUTHENTICATION_0");
    assert!(private_inputs[plaintext_authentication_len].contains_key("counter"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("nonce"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("key"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("plaintext"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("ciphertext_digest"));

    // assert http verification inputs
    let http_instruction_len = 1;
    assert_eq!(rom[http_instruction_len], "HTTP_VERIFICATION_0");
    assert!(private_inputs[http_instruction_len].contains_key("main_digests"));
    assert!(private_inputs[http_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[http_instruction_len].contains_key("data"));
    assert!(private_inputs[http_instruction_len].contains_key("machine_state"));

    // check final circuit is extract
    let json_instruction_len = 4;
    assert_eq!(rom[json_instruction_len], "JSON_EXTRACTION_0");
    assert!(private_inputs[json_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("data"));
    assert!(private_inputs[json_instruction_len].contains_key("sequence_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("value_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("state"));

    // fold inputs is empty
    assert!(fold_inputs.is_empty());
  }

  #[test]
  fn generate_rom_from_complex_inputs() {
    let manifest: Manifest = complex_manifest();
    let (request_inputs, response_inputs) = complex_inputs();

    let NivcCircuitInputs { fold_inputs, private_inputs, .. } =
      manifest.build_inputs(&request_inputs, &response_inputs).unwrap();
    let NIVCRom { circuit_data: rom_data, rom } =
      manifest.build_rom(&request_inputs, &response_inputs);

    // request:
    // plaintext_authentication (multiple chunks)
    // + http verification (divide into CIRCUIT_SIZE)
    // response:
    // plaintext_authentication (multiple chunks)
    // + http verification (divide into CIRCUIT_SIZE)
    // + json extraction (body divide into CIRCUIT_SIZE)
    assert_eq!(rom.len(), rom_data.len());

    // assert plaintext authentication inputs
    let plaintext_authentication_len = 0;
    assert_eq!(rom[plaintext_authentication_len], String::from("PLAINTEXT_AUTHENTICATION_0"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("counter"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("nonce"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("key"));
    assert!(private_inputs[plaintext_authentication_len].contains_key("plaintext"));

    // assert http parse inputs
    let http_instruction_len = 2;
    assert_eq!(rom[http_instruction_len], String::from("HTTP_VERIFICATION_0"));
    assert!(private_inputs[http_instruction_len].contains_key("main_digests"));
    assert!(private_inputs[http_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[http_instruction_len].contains_key("data"));

    // check final circuit is extract
    let json_instruction_len = 11;
    assert_eq!(rom[json_instruction_len], String::from("JSON_EXTRACTION_1"));
    assert!(private_inputs[json_instruction_len].contains_key("ciphertext_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("data"));
    assert!(private_inputs[json_instruction_len].contains_key("sequence_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("value_digest"));
    assert!(private_inputs[json_instruction_len].contains_key("state"));

    assert!(fold_inputs.is_empty());
  }

  #[test]
  fn test_to_u32_array() {
    // empty
    let input: Vec<u8> = vec![];
    let result = to_u32_array(&input);
    assert_eq!(result.len(), 0);

    // two incomplete u32
    let input = vec![1, 2, 3, 4, 5];
    let result = to_u32_array(&input);
    assert_eq!(result.len(), 2);
    assert_eq!(result[0], u32::from_le_bytes([1, 2, 3, 4]));
    assert_eq!(result[1], u32::from_le_bytes([5, 0, 0, 0]));

    // two complete u32
    let input = vec![1, 2, 3, 4, 5, 6, 7, 8];
    let result = to_u32_array(&input);
    assert_eq!(result.len(), 2);
    assert_eq!(result[0], u32::from_le_bytes([1, 2, 3, 4]));
    assert_eq!(result[1], u32::from_le_bytes([5, 6, 7, 8]));
  }

  #[test]
  fn test_u32_array_to_le_bits() {
    // basic
    let input = vec![0x80000000]; // Most significant bit set
    let result = u32_array_to_le_bits(&input);
    assert_eq!(result.len(), 1);
    assert_eq!(result[0].len(), 32);
    assert_eq!(result[0][0], 1); // First bit should be 1
    assert_eq!(result[0][1..].iter().sum::<u8>(), 0); // Rest should be 0

    // multiple small numbers
    let input = vec![0x1, 0x2]; // Two small numbers
    let result = u32_array_to_le_bits(&input);
    assert_eq!(result.len(), 2);

    // First number (0x1) should have only the last bit set
    assert_eq!(result[0][31], 1);
    assert_eq!(result[0][..31].iter().sum::<u8>(), 0);

    // Second number (0x2) should have the second-to-last bit set
    assert_eq!(result[1][30], 1);
    assert_eq!(result[1][..30].iter().chain(result[1][31..].iter()).sum::<u8>(), 0);

    // empty
    let input: Vec<u32> = vec![];
    let result = u32_array_to_le_bits(&input);
    assert_eq!(result.len(), 0);

    // all bits set
    let input = vec![0xFFFFFFFF];
    let result = u32_array_to_le_bits(&input);
    assert_eq!(result.len(), 1);
    assert_eq!(result[0].iter().sum::<u8>(), 32); // All bits should be 1

    // property-based test
    let original = vec![0x12345678, 0x9ABCDEF0];
    let bits = u32_array_to_le_bits(&original);

    // Convert bits back to u32s
    let reconstructed: Vec<u32> = bits
      .iter()
      .map(|bit_vec| {
        bit_vec.iter().enumerate().fold(0u32, |acc, (i, &bit)| acc | ((bit as u32) << (31 - i)))
      })
      .collect();

    assert_eq!(original, reconstructed);
  }

  #[test]
  fn test_to_chacha_input_integration() {
    // empty input
    let input: Vec<u8> = vec![];
    let result = to_chacha_input(&input);
    assert_eq!(result.len(), 0);

    // smal input
    let input = vec![0xFF, 0x00, 0xAA, 0x55]; // Test pattern
    let result = to_chacha_input(&input);

    assert_eq!(result.len(), 1); // Should produce one u32
    assert_eq!(result[0].len(), 32); // Each u32 produces 32 bits

    // Verify the bit pattern matches expected transformation
    let expected_u32 = u32::from_le_bytes([0xFF, 0x00, 0xAA, 0x55]);
    let expected_bits: Vec<u8> = (0..32).map(|i| ((expected_u32 >> (31 - i)) & 1) as u8).collect();
    assert_eq!(result[0], expected_bits);

    // large input
    let counter_u32 = [1];
    let res = to_u32_array(&counter_u32);
    assert_eq!(res, [1]);

    let counter_back = u32_array_to_le_bits(&res);
    assert_eq!(counter_back, vec![vec![
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1
    ]]);

    let http_u32 = "HTTP".as_bytes();
    assert_eq!(to_u32_array(http_u32), [1347703880]);

    let http_bits = u32_array_to_le_bits(&to_u32_array(http_u32));
    assert_eq!(http_bits, [[
      0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
      0
    ]]);
  }
}
